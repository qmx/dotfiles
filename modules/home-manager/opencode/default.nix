{
  config,
  lib,
  pkgs,
  modelsLib,
  ...
}:

let
  cfg = config.opencode;

  # Build models attrset for a provider using lib's converter
  buildProviderModels = modelNames: modelsLib.toOpencodeModels (modelsLib.selectModels modelNames);

  # Default display names for providers
  defaultNames = {
    local = "Local Llama Swap";
  };

  # Build a single provider config (without URL - will be injected by template)
  buildProvider = name: modelNames: {
    npm = "@ai-sdk/openai-compatible";
    name = cfg.providerNames.${name} or defaultNames.${name} or name;
    models = buildProviderModels modelNames;
  };

  # Generate opencode data (model configs, settings - no secrets)
  # Wrapped under "data" key to avoid collisions when merged with secrets
  # This will be combined with secrets by minijinja template
  opencodeData = {
    data = {
      providers = lib.mapAttrs buildProvider cfg.providers;
      defaultModel = cfg.defaultModel;
      smallModel = cfg.smallModel;
      agentModels = cfg.agentModels;
    };
  };

  jsonFormat = pkgs.formats.json { };
  dataFile = jsonFormat.generate "opencode-data.json" opencodeData;
in
{
  options.opencode = {
    providers = lib.mkOption {
      type = lib.types.attrsOf (lib.types.listOf lib.types.str);
      default = { };
      description = "Attrset of provider name to list of model names from catalog";
    };

    providerNames = lib.mkOption {
      type = lib.types.attrsOf lib.types.str;
      default = { };
      description = "Attrset of provider name to display name";
    };

    defaultModel = lib.mkOption {
      type = lib.types.str;
      default = "local/SmolLM3-3B-Q8";
      description = "Default model in provider/model format";
    };

    smallModel = lib.mkOption {
      type = lib.types.str;
      default = "local/SmolLM3-3B-Q8";
      description = "Small model for quick tasks";
    };

    agentModels = lib.mkOption {
      type = lib.types.attrsOf (lib.types.submodule {
        options = {
          model = lib.mkOption {
            type = lib.types.str;
            description = "Model for this agent in provider/model format";
          };
          description = lib.mkOption {
            type = lib.types.str;
            default = "";
            description = "Brief description of what the agent does";
          };
          mode = lib.mkOption {
            type = lib.types.nullOr (lib.types.enum [ "primary" "subagent" "all" ]);
            default = null;
            description = "Agent type";
          };
          temperature = lib.mkOption {
            type = lib.types.nullOr lib.types.float;
            default = null;
            description = "Response randomness (0.0-1.0)";
          };
          maxSteps = lib.mkOption {
            type = lib.types.nullOr lib.types.int;
            default = null;
            description = "Maximum agentic iterations";
          };
          tools = lib.mkOption {
            type = lib.types.attrsOf lib.types.bool;
            default = { };
            description = "Enable/disable specific tools for this agent";
          };
          prompt = lib.mkOption {
            type = lib.types.lines;
            default = "";
            description = "System prompt for custom agents (creates markdown file)";
          };
        };
      });
      default = { };
      description = "Per-agent config (plan, build, research, general, explore, title, summary, compaction)";
    };
  };

  config = lib.mkIf (cfg.providers != { }) {
    # Disable nixpkgs opencode from core.nix - we use the flake version instead
    programs.opencode.enable = lib.mkForce false;

    # nodejs provides npx for MCP servers (e.g., brave-search)
    # uv provides uvx for Python MCP servers (e.g., ddg-search)
    home.packages = [ pkgs.nodejs pkgs.uv ];

    # Deploy opencode data file (model configs without secrets)
    # Final opencode.json is generated by secrets module using template
    xdg.configFile."opencode/opencode-data.json".source = dataFile;
  };
}
