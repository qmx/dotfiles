#!/usr/bin/env bash
set -euo pipefail

# nixify-model - Add a local model to the nix-cache static store
#
# Usage: nixify-model "org/repo:quantization"
# Examples:
#   nixify-model "unsloth/Qwen3-VL-32B-Instruct-GGUF:Q8_K_XL"  # GGUF model
#   nixify-model "ggerganov/whisper.cpp:large-v3-turbo"        # Whisper model

CACHE_DIR="${NIX_CACHE_DIR:-/mnt/nix-cache/static}"
MODELS_DIR="${LLAMA_MODELS_DIR:-$HOME/.local/share/llama-models}"
WHISPER_DIR="${WHISPER_MODELS_DIR:-$HOME/.local/share/whisper-models}"
SECRET_KEY="${NIX_CACHE_SECRET_KEY:-$HOME/.secrets/nix-cache.sec}"

if [[ $# -lt 1 ]]; then
  echo "Usage: nixify-model <hf-identifier>"
  echo "Examples:"
  echo "  nixify-model 'unsloth/Qwen3-VL-32B-Instruct-GGUF:Q8_K_XL'  # GGUF"
  echo "  nixify-model 'ggerganov/whisper.cpp:large-v3-turbo'        # Whisper"
  exit 1
fi

if [[ ! -f "$SECRET_KEY" ]]; then
  echo "Error: Signing key not found at $SECRET_KEY"
  echo "Run 'home-manager switch' to decrypt secrets first."
  exit 1
fi

HF_ID="$1"

# Parse HF ID: "org/repo:quant" -> org, repo, quant
if [[ ! "$HF_ID" =~ ^([^/]+)/([^:]+):(.+)$ ]]; then
  echo "Error: Invalid HF identifier format"
  echo "Expected: org/repo:quantization"
  exit 1
fi

ORG="${BASH_REMATCH[1]}"
REPO="${BASH_REMATCH[2]}"
QUANT="${BASH_REMATCH[3]}"

# Detect if this is a whisper model
IS_WHISPER=false
if [[ "$REPO" == "whisper.cpp" ]]; then
  IS_WHISPER=true
fi

# Find model file(s)
if [[ "$IS_WHISPER" == "true" ]]; then
  # Whisper models: ggml-{model-name}.bin
  FILENAME="ggml-${QUANT}.bin"
  FILEPATH="${WHISPER_DIR}/${FILENAME}"
  if [[ ! -f "$FILEPATH" ]]; then
    echo "Error: Whisper model not found: $FILEPATH"
    exit 1
  fi
  MODEL_FILES=("$FILEPATH")
else
  # GGUF models: org_repo_*quant*.gguf
  PATTERN="${ORG}_${REPO}_*${QUANT}*.gguf"
  MODEL_FILES=($(ls "$MODELS_DIR"/$PATTERN 2>/dev/null || true))
  if [[ ${#MODEL_FILES[@]} -eq 0 ]]; then
    echo "Error: No files found matching pattern: $PATTERN"
    echo "Looking in: $MODELS_DIR"
    exit 1
  fi
fi

# Check for mmproj file (VL models only, not whisper)
HAS_MMPROJ=false
if [[ "$IS_WHISPER" != "true" ]]; then
  MMPROJ_PATTERN="${ORG}_${REPO}_mmproj*.gguf"
  MMPROJ_FILES=($(ls "$MODELS_DIR"/$MMPROJ_PATTERN 2>/dev/null || true))
  if [[ ${#MMPROJ_FILES[@]} -gt 0 ]]; then
    HAS_MMPROJ=true
    MMPROJ_FILE="${MMPROJ_FILES[0]}"
  fi
fi

echo "Found ${#MODEL_FILES[@]} model file(s):"
printf '  %s\n' "${MODEL_FILES[@]}"
if [[ "$HAS_MMPROJ" == "true" ]]; then
  echo "Found mmproj file (VL model):"
  echo "  $MMPROJ_FILE"
fi

# Process mmproj first if present
MMPROJ_FILENAME=""
MMPROJ_HASH=""
if [[ "$HAS_MMPROJ" == "true" ]]; then
  FILENAME=$(basename "$MMPROJ_FILE")
  MMPROJ_FILENAME=$(echo "$FILENAME" | sed "s/^${ORG}_${REPO}_//")

  echo ""
  echo "Processing mmproj: $FILENAME"
  echo "  HF filename: $MMPROJ_FILENAME"

  echo "  Computing hash..."
  MMPROJ_HASH=$(nix hash file --sri "$MMPROJ_FILE")
  echo "  SHA256 (SRI): $MMPROJ_HASH"

  echo "  Adding to Nix store..."
  STORE_PATH=$(nix store add-file --name "$MMPROJ_FILENAME" "$MMPROJ_FILE")
  echo "  Store path: $STORE_PATH"

  echo "  Copying to cache with signing..."
  nix copy --to "file://${CACHE_DIR}?compression=zstd" \
    --secret-key-files "$SECRET_KEY" \
    "$STORE_PATH"
  echo "  Done!"
fi

# Detect if this is a split model (multiple files)
IS_SPLIT=false
if [[ ${#MODEL_FILES[@]} -gt 1 ]]; then
  IS_SPLIT=true
fi

# Arrays to collect split file info
declare -a SPLIT_NAMES=()
declare -a SPLIT_HASHES=()

# Process main model file(s)
for FILE in "${MODEL_FILES[@]}"; do
  FILENAME=$(basename "$FILE")

  if [[ "$IS_WHISPER" == "true" ]]; then
    # Whisper files are already in correct format (ggml-{name}.bin)
    HF_FILENAME="$FILENAME"
  else
    # GGUF: Remove org_repo_ prefix
    HF_FILENAME=$(echo "$FILENAME" | sed "s/^${ORG}_${REPO}_//")

    # For split files in subfolders, convert first _ after quant pattern to /
    # e.g., "UD-Q8_K_XL_model-name.gguf" -> "UD-Q8_K_XL/model-name.gguf"
    if [[ "$IS_SPLIT" == "true" && "$HF_FILENAME" =~ ^(UD-${QUANT})_(.+)$ ]]; then
      HF_FILENAME="${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
    fi
  fi

  echo ""
  echo "Processing: $FILENAME"
  echo "  HF filename: $HF_FILENAME"

  echo "  Computing hash..."
  FILE_HASH=$(nix hash file --sri "$FILE")
  echo "  SHA256 (SRI): $FILE_HASH"

  echo "  Adding to Nix store..."
  # Use just the basename for store path (no slashes)
  STORE_NAME=$(basename "$HF_FILENAME")
  STORE_PATH=$(nix store add-file --name "$STORE_NAME" "$FILE")
  echo "  Store path: $STORE_PATH"

  echo "  Copying to cache with signing..."
  nix copy --to "file://${CACHE_DIR}?compression=zstd" \
    --secret-key-files "$SECRET_KEY" \
    "$STORE_PATH"
  echo "  Done!"

  if [[ "$IS_SPLIT" == "true" ]]; then
    # Collect for split output
    SPLIT_NAMES+=("$HF_FILENAME")
    SPLIT_HASHES+=("$FILE_HASH")
  else
    # Output single file ggufs catalog entry
    echo ""
    echo "Add to lib/ggufs.nix ggufs section:"
    echo ""
    echo "    \"$HF_ID\" = {"
    echo "      file = \"$HF_FILENAME\";"
    echo "      sha256 = \"$FILE_HASH\";"
    if [[ "$HAS_MMPROJ" == "true" ]]; then
      echo "      mmproj = {"
      echo "        file = \"$MMPROJ_FILENAME\";"
      echo "        sha256 = \"$MMPROJ_HASH\";"
      echo "      };"
    fi
    echo "    };"
  fi
done

# Output split file ggufs catalog entry
if [[ "$IS_SPLIT" == "true" ]]; then
  echo ""
  echo "Add to lib/ggufs.nix ggufs section:"
  echo ""
  echo "    \"$HF_ID\" = {"
  echo "      files = ["
  for i in "${!SPLIT_NAMES[@]}"; do
    echo "        { name = \"${SPLIT_NAMES[$i]}\"; sha256 = \"${SPLIT_HASHES[$i]}\"; }"
  done
  echo "      ];"
  if [[ "$HAS_MMPROJ" == "true" ]]; then
    echo "      mmproj = {"
    echo "        file = \"$MMPROJ_FILENAME\";"
    echo "        sha256 = \"$MMPROJ_HASH\";"
    echo "      };"
  fi
  echo "    };"
fi

echo ""
echo "Done! Files are in $CACHE_DIR"
